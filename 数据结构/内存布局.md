
# 结构

* __text__

> 包含程序文本，也就是程序所组成的指令等

* __static__

> 包含由编译器所分配的变量，包括全局变量，以及使用 static 声明的局部变量

* __stack__

> 由系统来管理的栈，在运行时管理各种函数的调用以及变量等

* __heap__

> heap 含运行时分配的内存块，通常通过调用C标准库函数malloc来分配

## 细节

* text 段靠近内存"底部", 接近0的位置

* static 段通常在 text 段上面

* stack 段靠近内存顶部，在扩张的过程中，向低地址方向增长

* heap 段通常在 static 段上面，在扩张的过程中，向高地址方向增长

* 函数调用时产生的局部变量，在调用时被自动分配在栈上，并在函数返回时自动被释放


# 内存对齐(字节对齐)

> 现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

## __原因__

* __平台原因__：各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。 比如，有些架构的CPU在访问 一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。

* __性能原因__：内存对齐可以提高存取效率。比如，有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那么一个读周期就可以读出这32bit，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该32bit数据。

## 规则

> 每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。你可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16 来改变这一系数，其中 n 就是你要指定的“对齐系数”

1) 结构体变量的 __首地址__ 是有效对齐值（对齐单位）的整数倍。

2) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

3) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

4) 结构体内类型相同的连续元素将在连续的空间内，和数组一样。

## 例子

1)

```
struct
{
    int i;    // 4个字节
    char c1;  // 1个字节
    char c2;  // 1个字节
}x1;

struct
{
    char c1;  // 1个字节
    int i;    // 4个字节
    char c2;  // 1个字节
}x2;

struct
{
    char c1;  // 1个字节
    char c2;  // 1个字节
    int i;    // 4个字节
}x3;

int main()
{
    printf("%d\n",sizeof(x1));  // 输出8
    printf("%d\n",sizeof(x2));  // 输出12
    printf("%d\n",sizeof(x3));  // 输出8
    return 0;
}

```

* __ref__

[C/C++内存对齐](https://songlee24.github.io/2014/09/20/memory-alignment/)